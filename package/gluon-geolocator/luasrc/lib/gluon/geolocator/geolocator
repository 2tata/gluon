#!/usr/bin/lua

local bit = require('bit')
local unistd = require('posix.unistd')
local fcntl = require('posix.fcntl')
local uci = require('simple-uci').cursor()
local json = require ("jsonc")
local ubus = require 'ubus'
local iwinfo = require("iwinfo")

local LOC="gluon-node-info"
local GLC="geolocator"

if not uci:get_bool(GLC, "settings", "auto_location") then
	os.exit(0)
end

-- PID file to ensure the geolocator isn't running parallel
local lockfile = '/var/lock/geolocator.lock'
local lockfd, err = fcntl.open(lockfile, bit.bor(fcntl.O_WRONLY, fcntl.O_CREAT), 384) -- mode 0600

if not lockfd then
	io.stderr:write(err, '\n')
	os.exit(1)
end

local ok, _ = fcntl.fcntl(lockfd, fcntl.F_SETLK, {
	l_start = 0,
	l_len = 0,
	l_type = fcntl.F_WRLCK,
	l_whence = unistd.SEEK_SET,
})

if not ok then
	io.stderr:write(string.format(
		"Unable to lock file %s. Make sure there is no other instance of the geolocator running.\n",
		lockfile
	))
	os.exit(1)
end

-- Iterates over all active WLAN interfaces
-- Returning true from the callback function will skip all remaining
-- interfaces of the same radio
local function foreach_radio(f)
	local uconn = assert(ubus.connect(), 'failed to connect to ubus')
	local status = uconn:call('network.wireless', 'status', {})
	ubus.close(uconn)

	for _, radio in pairs(status) do
		for _, iface in ipairs(radio.interfaces) do
			if f(iface.ifname) then
				break
			end
		end
	end
end

local function receive_json(request)
	local f = assert(io.popen(string.format("exec wget -T 15 -q -O- '%s'", request)), 'failed to run wget')
	local data = f:read('*a')
	f:close()

	return json.parse(data)
end

-- Get position
local function locate()
	local done_bssids = {}
	local found_bssids = {}
	foreach_radio(function(ifname)
		local iw = iwinfo[iwinfo.type(ifname)]
		if not iw then
			-- Skip other ifaces of this radio, as they
			-- will have the same type
			return true
		end

		local scanlist = iw.scanlist(ifname)
		if not scanlist then
			return false
		end

		for _, entry in ipairs(scanlist) do
			if entry.mode:match("Master") then
				local bssid = string.upper(entry.bssid:gsub(":", ""))
				if not done_bssids[bssid] then
					table.insert(found_bssids, bssid)
					done_bssids[bssid] = true
				end
			end
		end

		return true
	end)

	assert(#found_bssids > 0, 'insufficient BSSIDs found')

	local data = receive_json('http://openwifi.su/api/v1/bssids/' .. table.concat(found_bssids, ','))
	assert(type(data) == 'table' and data.lon and data.lat, 'location not available')

	return data
end

local pos = locate()
if not next(pos) then
	os.exit(1)
end

if not uci:get_bool(GLC, "settings", "static_location") then

	local old_lat = uci:get(LOC, uci:get_first(LOC, 'location'), 'latitude')
	local old_lon = uci:get(LOC, uci:get_first(LOC, 'location'), 'longitude')

	uci:set(LOC, uci:get_first(LOC, 'location'), 'latitude', pos.lat)
	uci:set(LOC, uci:get_first(LOC, 'location'), 'longitude', pos.lon)
	uci:save(LOC)

	-- Commit only if no coordinates have been stored before or the Nodes Pos have change significantly +- 22m
	if (old_lat == nil or old_lon == nil) or ( math.abs(math.abs(old_lat) - math.abs(pos.lat)) > 0.0002 or math.abs(math.abs(old_lon) - math.abs(pos.lon)) > 0.0002 ) then
		uci:commit(LOC)
	end
end
os.exit(0)
